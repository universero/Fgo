# 基于前缀树的路由匹配

代码详见/code/3，此处不予赘述

## 基于前缀树的路由匹配

路由的格式形如/part1/part2，且采用从左往右的方式匹配，那么只需将两个/间的字符串作为判断依据依次匹配即可。

先前的路由管理使用的是整个路径作为key，实现简单，但是没法做到带有参数的路由和带有通配符的路由，按照/切分构造前缀树可以实现更细粒度的路由管理

```go
type node struct {
	pattern  string  // 该节点匹配的路由，例如 /p/:lang
	part     string  // 路由中的一部分，例如:lang
	children []*node // 子节点，例如[doc,intro]
	isWild   bool    // 是否精确匹配, part 含有 : 或 * 时为true，表示非精确匹配
}
```

前缀树节点有四个字段
- pattern：该节点匹配的路由，是一个完整的路由，只有作为一个有效的路由时，pattern才有值，否则作为中间节点值为空
- part：当前节点的部分，不包含前后的其他部分
- children：子节点
- isWild：当以: 或 * 开头时为true，表示非精确匹配


插入时，每次都找第一个匹配的往后插入
匹配时：对于:和*都作为通配符进行匹配，在找到对于的pattern后再进行参数的替换